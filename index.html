<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>4D ä¸‰ç›®æ ‡æŒ‘æˆ˜</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #000; color: #aaa;
            font-family: 'Consolas', monospace; touch-action: none;
            user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* HUD */
        #hud {
            position: absolute; top: 10px; left: 10px; pointer-events: none;
            font-size: 11px; background: rgba(0,0,0,0.8);
            padding: 8px; border: 1px solid #333; border-left: 2px solid #0f0;
        }
        .val { color: #fff; font-weight: bold; margin-left: 5px; }
        .val-w { color: #0af; font-weight: bold; margin-left: 5px; transition: text-shadow 0.1s; }
        .val-w.pulse { text-shadow: 0 0 8px #0af, 0 0 15px #0af; }

        /* ç›®æ ‡æ¸…å• */
        #goal-panel {
            position: absolute; top: 10px; right: 10px; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #333;
            text-align: right; font-size: 11px;
        }
        .goal-row { margin-bottom: 4px; font-weight: bold; }
        .done { text-decoration: line-through; opacity: 0.5; color: #888 !important; }

        /* æ§ä»¶ */
        #btn-reset {
            position: absolute; top: 100px; left: 10px; pointer-events: auto;
            background: #111; border: 1px solid #444; color: #888;
            padding: 6px 12px; border-radius: 4px; font-weight: bold; font-size: 11px;
        }
        #btn-toggle {
            position: absolute; top: 10px; left: 140px; pointer-events: auto;
            background: #111; border: 1px solid #0af; color: #0af;
            padding: 6px 10px; border-radius: 4px; font-weight: bold; font-size: 11px;
        }

        /* è­¦å‘Šå±‚ */
        #alert-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0); transition: box-shadow 0.1s;
        }
        #alert-layer.active { box-shadow: inset 0 0 80px 40px rgba(200, 0, 0, 0.3); }
        #alert-layer.w-move { box-shadow: inset 0 0 60px 30px rgba(0, 170, 255, 0.2); }

        #center-msg {
            position: absolute; top: 40%; width: 100%; text-align: center;
            color: #f33; font-weight: bold; font-size: 16px; display: none; pointer-events: none;
            text-shadow: 0 0 5px #000; letter-spacing: 2px;
        }

        /* Wè½´ */
        .w-controls {
            position: absolute; right: 20px; bottom: 160px;
            display: flex; flex-direction: column; gap: 15px; pointer-events: auto;
        }
        .btn-w {
            width: 50px; height: 50px; border-radius: 50%;
            background: rgba(0, 40, 80, 0.5); border: 1px solid rgba(0, 160, 255, 0.5);
            color: #0af; font-weight: bold; font-size: 12px;
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(2px);
        }
        .btn-w:active { background: #0af; color: #000; transform: scale(0.9); }

        /* æ‘‡æ† */
        .controls-area {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 30px;
            box-sizing: border-box; pointer-events: auto;
        }
        .joystick {
            width: 100px; height: 100px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 50%; position: relative;
        }
        .knob {
            width: 30px; height: 30px; background: rgba(0, 255, 150, 0.3);
            border: 1px solid rgba(0, 255, 150, 0.5); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;
        }
        .label {
            position: absolute; width: 100%; text-align: center; top: 110px;
            font-size: 10px; color: #555; font-weight: bold;
        }

        #win-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); border: 1px solid #ffd700; padding: 20px;
            text-align: center; display: none; color: #ffd700; z-index: 100; font-size: 14px;
        }
    </style>
</head>
<body>

<div id="alert-layer"></div>
<div id="center-msg">ğŸš« è¾¹ç•Œé˜»æŒ¡</div>
<canvas id="canvas"></canvas>

<div id="hud">
    <div>POS X:<span id="vx" class="val">0.0</span></div>
    <div>POS Z:<span id="vz" class="val">0.0</span></div>
    <div>POS W:<span id="vw" class="val-w">0.0</span></div>
    <div style="margin-top:5px; padding-top:5px; border-top:1px solid #333;">
        <div>Yaw:<span id="vyaw" class="val">0Â°</span></div>
        <div>Pitch:<span id="vpitch3d" class="val">0Â°</span></div>
        <div>Pitch4D:<span id="vpitch4d" class="val-w">0Â°</span></div>
    </div>
</div>

<!-- ç›®æ ‡é¢æ¿ -->
<div id="goal-panel">
    <div id="g-x" class="goal-row" style="color:#f55">TARGET X: --</div>
    <div id="g-z" class="goal-row" style="color:#fd0">TARGET Z: --</div>
    <div id="g-w" class="goal-row" style="color:#0ff">TARGET W: --</div>
</div>

<button id="btn-toggle">å¢™ä½“: ON</button>
<button id="btn-reset">é‡ç½®</button>

<div id="win-screen">
    <h2 style="margin:0 0 10px 0">ä»»åŠ¡å®Œæˆ</h2>
    <div style="color:#aaa">æ‰€æœ‰ç›®æ ‡å·²æ•è·</div>
</div>

<div class="w-controls">
    <button class="btn-w" id="btn-k">W+</button>
    <button class="btn-w" id="btn-a">W-</button>
</div>

<div class="controls-area">
    <div class="joystick" id="stick-l">
        <div class="knob" id="knob-l"></div>
        <div class="label">MOVE</div>
    </div>
    <div class="joystick" id="stick-r">
        <div class="knob" id="knob-r"></div>
        <div class="label">LOOK</div>
    </div>
</div>

<script>
try {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // UI Refs
    const ui = {
        x: document.getElementById('vx'),
        z: document.getElementById('vz'),
        w: document.getElementById('vw'),
        yaw: document.getElementById('vyaw'),
        pitch: document.getElementById('vpitch3d'),
        pitch4d: document.getElementById('vpitch4d'),
        msg: document.getElementById('center-msg'),
        alert: document.getElementById('alert-layer'),
        toggle: document.getElementById('btn-toggle'),
        win: document.getElementById('win-screen'),
        // Goals
        gx: document.getElementById('g-x'),
        gz: document.getElementById('g-z'),
        gw: document.getElementById('g-w')
    };

    function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = '100vw';
        canvas.style.height = '100vh';
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 1. é…ç½® ---
    const CONFIG = {
        bound: 6.0,
        eyeY: 0.5,
        floorY: 0.0,

        // è°ƒæ•´ç„¦è·ä»¥åŒ¹é…çº¿æ€§æŠ•å½±çš„æ–°é€»è¾‘ï¼Œä¿æŒè§†è§‰å¤§å°ä¸€è‡´
        // ä¹‹å‰ focal3D=600, focal4D=2.8.
        // çº¿æ€§æŠ•å½±ä¸‹ï¼Œå¤§çº¦ 250 çš„ç»Ÿä¸€ç„¦è·èƒ½è·å¾—ç±»ä¼¼çš„è§†åœºè§’
        focalLinear: 250,

        nearClip: 0.2,
        renderDist: 14.0,

        speedM: 0.05,
        speedR: 0.02,
        speedW: 0.04,
        playerR: 0.3
    };

    // åˆå§‹ä½ç½®: Z=-4.5
    const SPAWN = { x:0, y:CONFIG.eyeY, z:-4.5, w:0, yaw:0, pitch:0, pitch4D:0 };
    let cam = { ...SPAWN };
    let input = { mx:0, mz:0, lx:0, ly:0, w:0 };
    let showWalls = true;
    let finished = false;

    // --- ç›®æ ‡æ•°æ® ---
    // ä¸‰ä¸ªç›®æ ‡ç‚¹
    let goals = [
        { id: 'x', name: "TARGET X", x: 5.0, y: 0.5, z: 0, w: 0, color: "#f55", done: false, el: ui.gx },
        { id: 'z', name: "TARGET Z", x: 0, y: 0.5, z: 5.0, w: 0, color: "#fd0", done: false, el: ui.gz },
        { id: 'w', name: "TARGET W", x: 0, y: 0.5, z: 0, w: 5.0, color: "#0ff", done: false, el: ui.gw }
    ];

    // --- 2. åœºæ™¯æ„å»º (å®Œå…¨å¤ç”¨ é«˜å¯†åº¦ç‰ˆ é€»è¾‘) ---
    let renderList = { lines: [], dots: [] };

    function addLine(p1, p2, color, width=1) { renderList.lines.push({p1, p2, color, width}); }
    function addDot(p, color, size=1.5, type=0) { renderList.dots.push({p, color, size, type}); }

    // 2.1 åœ°é¢ (é«˜å¯†åº¦)
    {
        const range = 6.0;
        const stepXZ = 0.5; // XZå¹³é¢é«˜å¯†åº¦: 0.5
        const stepW = 1.5;  // Wè½´åˆ†å±‚é—´è·: 1.5
        const y = CONFIG.floorY;

        for(let w = -range; w <= range + 0.1; w += stepW) {
            for(let x = -range; x <= range + 0.1; x += stepXZ) {
                for(let z = -range; z <= range + 0.1; z += stepXZ) {

                    let p = {x, y, z, w};
                    addDot(p, "#444", 1.2, 0);

                    if(x + stepXZ <= range + 0.1) addLine(p, {x:x+stepXZ, y, z, w}, "#222", 0.5);
                    if(z + stepXZ <= range + 0.1) addLine(p, {x, y, z:z+stepXZ, w}, "#222", 0.5);
                    if(w + stepW <= range + 0.1) addLine(p, {x, y, z, w:w+stepW}, "#113", 0.5);
                }
            }
        }
    }

    // 2.2 è¾¹ç•Œ (é«˜å¯†åº¦)
    {
        const b = CONFIG.bound;
        const step = 0.5;
        let axes = ['x', 'z', 'w'];
        let vals = [-b, b];

        function genEdge(fixedAxis1, val1, fixedAxis2, val2, runAxis) {
            for(let v = -b; v <= b; v += step) {
                let p = {x:0, y:0, z:0, w:0};
                p[fixedAxis1] = val1;
                p[fixedAxis2] = val2;
                p[runAxis] = v;

                addDot(p, "#f00", 2.0, 1);

                if (v + step <= b + 0.1) {
                    let pNext = {...p};
                    pNext[runAxis] = v + step;
                    addLine(p, pNext, "#800", 1.5);
                }
            }
        }

        vals.forEach(vz => vals.forEach(vw => genEdge('z', vz, 'w', vw, 'x')));
        vals.forEach(vx => vals.forEach(vw => genEdge('x', vx, 'w', vw, 'z')));
        vals.forEach(vx => vals.forEach(vz => genEdge('x', vx, 'z', vz, 'w')));
    }

    // 2.3 å¢™ä½“
    let wallColliders = [];
    for(let x = -2; x <= 2; x += 1.2) {
        let cx = x, cy = 0.5, cz = 0, cw = 0;
        let r = 0.5;
        let v = [];
        for(let k=0; k<8; k++) {
            v.push({
                x: cx + ((k&1)?r:-r),
                y: cy + ((k&2)?r:-r),
                z: cz + ((k&4)?r:-r),
                w: cw
            });
        }
        const edges = [[0,1],[1,3],[3,2],[2,0], [4,5],[5,7],[7,6],[6,4], [0,4],[1,5],[2,6],[3,7]];

        wallColliders.push({
            lines: edges.map(e => ({p1:v[e[0]], p2:v[e[1]], color:"#0cc", width:1.5})),
            dots: v.map(p => ({p, color:"#0ff", size:2.0})),
            cx, cz, cw, r:0.6
        });
    }

    // 2.4 èµ·ç‚¹æ ‡è®° (Starting point marker)
    {
        const sp = { x: SPAWN.x, y: SPAWN.y, z: SPAWN.z, w: SPAWN.w };
        const arrowLen = 2.0;
        const headLen = 0.3;

        // Big yellow starting point dot
        addDot(sp, "#ff0", 5.0, 1);

        // Helper to draw arrow with arrowhead
        function drawArrow(start, dir, color) {
            const end = {
                x: start.x + dir.x * arrowLen,
                y: start.y + dir.y * arrowLen,
                z: start.z + dir.z * arrowLen,
                w: start.w + dir.w * arrowLen
            };

            // Main arrow line
            addLine(start, end, color, 3);

            // Arrowhead - two lines forming a V
            // Calculate perpendicular directions for arrowhead
            const backDir = { x: -dir.x, y: -dir.y, z: -dir.z, w: -dir.w };

            // For X arrow, use Z for perpendicular
            // For Z arrow, use X for perpendicular
            // For W arrow, use Y for perpendicular
            let perp1, perp2;
            if (dir.x !== 0) {
                perp1 = { x: 0, y: 0.5, z: 0.5, w: 0 };
                perp2 = { x: 0, y: 0.5, z: -0.5, w: 0 };
            } else if (dir.z !== 0) {
                perp1 = { x: 0.5, y: 0.5, z: 0, w: 0 };
                perp2 = { x: -0.5, y: 0.5, z: 0, w: 0 };
            } else {
                perp1 = { x: 0.5, y: 0.5, z: 0, w: 0 };
                perp2 = { x: -0.5, y: 0.5, z: 0, w: 0 };
            }

            const head1 = {
                x: end.x + (backDir.x + perp1.x) * headLen,
                y: end.y + (backDir.y + perp1.y) * headLen,
                z: end.z + (backDir.z + perp1.z) * headLen,
                w: end.w + (backDir.w + perp1.w) * headLen
            };
            const head2 = {
                x: end.x + (backDir.x + perp2.x) * headLen,
                y: end.y + (backDir.y + perp2.y) * headLen,
                z: end.z + (backDir.z + perp2.z) * headLen,
                w: end.w + (backDir.w + perp2.w) * headLen
            };

            addLine(end, head1, color, 2.5);
            addLine(end, head2, color, 2.5);

            // Dot at arrow tip
            addDot(end, color, 3.0, 1);
        }

        // X direction arrow (red)
        drawArrow(sp, { x: 1, y: 0, z: 0, w: 0 }, "#f55");

        // Z direction arrow (yellow/green)
        drawArrow(sp, { x: 0, y: 0, z: 1, w: 0 }, "#5f5");

        // W direction arrow (cyan)
        drawArrow(sp, { x: 0, y: 0, z: 0, w: 1 }, "#0ff");
    }

    // --- 3. æ¸²æŸ“ç®¡çº¿ (æ ¸å¿ƒä¿®æ”¹ï¼šçº¿æ€§æŠ•å½±) ---

    function project(p) {
        let tx = p.x - cam.x;
        let ty = p.y - cam.y;
        let tz = p.z - cam.z;
        let tw = p.w - cam.w;

        // Yaw rotation (horizontal, around Y axis)
        let c = Math.cos(cam.yaw), s = Math.sin(cam.yaw);
        let rx = tx*c - tz*s;
        let ry = ty;
        let rz = tx*s + tz*c;
        let rw = tw;

        // Pitch rotation (vertical, around X axis - FPS style look up/down)
        let cp = Math.cos(cam.pitch), sp = Math.sin(cam.pitch);
        let ry2 = ry*cp - rz*sp;
        let rz3 = ry*sp + rz*cp;

        // Pitch4D rotation (Z-W plane rotation for 4D viewing)
        let c4 = Math.cos(cam.pitch4D), s4 = Math.sin(cam.pitch4D);
        let rz4 = rz3*c4 - rw*s4;
        let rw2 = rz3*s4 + rw*c4;

        // è·ç¦»è®¡ç®—ç”¨äºé€æ˜åº¦ (ä¸å˜)
        let dist = Math.sqrt(rx*rx + ry2*ry2 + rz4*rz4 + rw2*rw2);

        // --- NEW: çº¿æ€§æ·±åº¦è®¡ç®— ---
        // ä½¿ç”¨åŠ æ³•è€Œä¸æ˜¯ä¹˜æ³•æ¥åˆå¹¶æ·±åº¦ã€‚
        // å…¬å¼ï¼šDepth = Z + W + Offset
        // è¿™ä¿è¯äº†çº¿æ€§æ–¹ç¨‹ä¿æŒçº¿æ€§ï¼ˆç›´çº¿å˜ç›´çº¿ï¼‰

        let depth = rz4 + rw2 + 3.0; // 3.0 æ˜¯ç›¸æœºåç§»ï¼Œé˜²æ­¢è¿‘å¤„è£åˆ‡å¤ªç”Ÿç¡¬

        if (depth < CONFIG.nearClip) return null;

        let scale = CONFIG.focalLinear / depth;

        return {
            x: window.innerWidth/2 + rx * scale,
            y: window.innerHeight/2 - ry2 * scale,
            dist: dist,
            scale: scale
        };
    }

    // ç»˜å›¾ (ä¿æŒåŸæ ·ï¼Œæ— éœ€ç»†åˆ†)
    function drawLine(l) {
        let pp1 = project(l.p1);
        let pp2 = project(l.p2);
        if(!pp1 || !pp2) return;

        let dist = (pp1.dist + pp2.dist) / 2;
        let alpha = Math.max(0, 1.0 - (dist / CONFIG.renderDist));
        if(alpha <= 0.01) return;

        ctx.strokeStyle = l.color;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = l.width;
        ctx.beginPath();
        ctx.moveTo(pp1.x, pp1.y);
        ctx.lineTo(pp2.x, pp2.y);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    function drawDot(d) {
        let pp = project(d.p);
        if(!pp) return;

        let alpha = Math.max(0, 1.0 - (pp.dist / CONFIG.renderDist));
        if(alpha <= 0.01) return;

        ctx.fillStyle = d.color;
        ctx.globalAlpha = alpha;

        let r = Math.min(d.size, 1.5);
        if (pp.dist > 5.0) r *= (5.0 / pp.dist);

        ctx.beginPath();
        ctx.arc(pp.x, pp.y, r, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    // ç»˜åˆ¶ç›®æ ‡ç‚¹
    function drawGoal(g) {
        if(g.done) return;
        let pp = project({x:g.x, y:g.y, z:g.z, w:g.w});
        if(pp) {
            let alpha = Math.max(0, 1.0 - (pp.dist / CONFIG.renderDist));
            if(alpha <= 0.01) return;

            let wDiff = Math.abs(g.w - cam.w);
            let highlight = Math.max(0.2, 1 - wDiff/1.5);

            ctx.fillStyle = g.color;
            ctx.globalAlpha = alpha * highlight;

            // ç›®æ ‡ç‚¹å¤§å°åŸºäºæ–°çš„ scale
            let r = Math.min(6, 60 * pp.scale);

            ctx.beginPath(); ctx.arc(pp.x, pp.y, r, 0, Math.PI*2); ctx.fill();

            // æ–‡å­—
            if(alpha > 0.3) {
                ctx.font = "bold 11px Consolas";
                ctx.textAlign = "center";
                ctx.fillText(g.name, pp.x, pp.y - 10);
            }
            ctx.globalAlpha = 1.0;
        }
    }

    function render() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        renderList.lines.forEach(drawLine);
        renderList.dots.forEach(drawDot);

        if(showWalls) {
            wallColliders.forEach(obj => {
                obj.lines.forEach(drawLine);
                obj.dots.forEach(drawDot);
            });
        }
        goals.forEach(drawGoal);
    }

    // --- 4. é€»è¾‘ (ä¿æŒä¿®å¤åçš„å„å‘åŒæ€§) ---
    function checkCollision(nx, nz, nw) {
        if(Math.abs(nx)>CONFIG.bound || Math.abs(nz)>CONFIG.bound || Math.abs(nw)>CONFIG.bound) return true;
        if(!showWalls) return false;
        let p = {x:nx, z:nz, w:nw};
        for(let w of wallColliders) {
            if(Math.abs(p.x - w.cx) < w.r && Math.abs(p.z - w.cz) < w.r && Math.abs(p.w - w.cw) < w.r) {
                return true;
            }
        }
        return false;
    }

    function update() {
        if(finished) return;

        cam.yaw += input.lx * CONFIG.speedR;
        cam.pitch -= input.ly * CONFIG.speedR;
        // Clamp pitch to prevent flipping (like FPS games)
        cam.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cam.pitch));

        // XZWå„å‘åŒæ€§ç§»åŠ¨é€»è¾‘
        let c = Math.cos(cam.yaw);
        let s = Math.sin(cam.yaw);
        let c4 = Math.cos(cam.pitch4D);
        let s4 = Math.sin(cam.pitch4D);

        let im_z = input.mz * CONFIG.speedM;
        let im_w = input.w * CONFIG.speedW;

        // æœ¬åœ° Z/W é€Ÿåº¦ -> ä¸–ç•Œ Z/W é€Ÿåº¦
        let rmz = im_z * c4 - im_w * s4;
        let rw  = im_z * s4 + im_w * c4;

        // æœ¬åœ° X/Z é€Ÿåº¦ -> ä¸–ç•Œ X/Z é€Ÿåº¦
        let dx = (input.mx * CONFIG.speedM * c - rmz * s);
        let dz = (-input.mx * CONFIG.speedM * s - rmz * c);
        let dw = rw;

        let nx = cam.x + dx;
        let nz = cam.z + dz;
        let nw = cam.w + dw;

        let hit = false;
        if(checkCollision(nx, cam.z, cam.w)) { nx = cam.x; hit = true; }
        if(checkCollision(nx, nz, cam.w)) { nz = cam.z; hit = true; }
        if(checkCollision(nx, nz, nw)) { nw = cam.w; hit = true; }

        cam.x = nx; cam.z = nz; cam.w = nw;

        if(hit) {
            ui.alert.classList.add('active');
            ui.alert.classList.remove('w-move');
            ui.msg.style.display = 'block';
        } else {
            ui.alert.classList.remove('active');
            ui.msg.style.display = 'none';
            // Show blue glow when moving in W dimension
            if (input.w !== 0) {
                ui.alert.classList.add('w-move');
            } else {
                ui.alert.classList.remove('w-move');
            }
        }

        // ç›®æ ‡æ£€æµ‹
        let allDone = true;
        goals.forEach(g => {
            if(!g.done) {
                let d = Math.sqrt((cam.x-g.x)**2 + (cam.z-g.z)**2 + (cam.w-g.w)**2);
                g.el.innerText = `${g.name}: ${d.toFixed(1)}m`;
                if(d < 0.8) {
                    g.done = true;
                    g.el.classList.add('done');
                } else {
                    allDone = false;
                }
            } else {
                g.el.innerText = `${g.name}: DONE`;
            }
        });

        if(allDone) {
            ui.win.style.display = 'block';
            finished = true;
        }

        ui.x.innerText = cam.x.toFixed(1);
        ui.z.innerText = cam.z.toFixed(1);
        ui.w.innerText = cam.w.toFixed(1);
        // Pulse W value when moving in W dimension
        if (input.w !== 0) {
            ui.w.classList.add('pulse');
        } else {
            ui.w.classList.remove('pulse');
        }
        ui.yaw.innerText = (cam.yaw * 180 / Math.PI % 360).toFixed(0) + "Â°";
        ui.pitch.innerText = (cam.pitch * 180 / Math.PI).toFixed(0) + "Â°";
        ui.pitch4d.innerText = (cam.pitch4D * 180 / Math.PI % 360).toFixed(0) + "Â°";
    }

    function loop() {
        update();
        render();
        requestAnimationFrame(loop);
    }
    loop();

    // --- 5. äº¤äº’ ---
    ui.toggle.onclick = () => {
        showWalls = !showWalls;
        ui.toggle.innerText = showWalls ? "å¢™ä½“: ON" : "å¢™ä½“: OFF";
        ui.toggle.style.color = showWalls ? "#0af" : "#555";
        ui.toggle.style.borderColor = showWalls ? "#0af" : "#555";
    };
    document.getElementById('btn-reset').onclick = () => {
        cam = { ...SPAWN };
        finished = false;
        ui.win.style.display = 'none';
        goals.forEach(g => { g.done = false; g.el.classList.remove('done'); });
    };

    function bindJoy(id, kId, cb) {
        let area = document.getElementById(id);
        let knob = document.getElementById(kId);
        let sx, sy;
        const move = (cx, cy) => {
            let dx = cx - sx, dy = cy - sy;
            let d = Math.sqrt(dx*dx+dy*dy);
            if(d>40) { dx=dx/d*40; dy=dy/d*40; }
            knob.style.transform = `translate(-50%,-50%) translate(${dx}px,${dy}px)`;
            cb(dx/40, dy/40);
        };
        area.addEventListener('touchstart', e=>{
            e.preventDefault(); sx=e.changedTouches[0].clientX; sy=e.changedTouches[0].clientY;
            knob.style.display='block'; cb(0,0);
        });
        area.addEventListener('touchmove', e=>{ e.preventDefault(); move(e.changedTouches[0].clientX, e.changedTouches[0].clientY); });
        const end = e=>{ e.preventDefault(); knob.style.display='none'; cb(0,0); };
        area.addEventListener('touchend', end); area.addEventListener('touchcancel', end);
    }

    bindJoy('stick-l', 'knob-l', (x,y)=> { input.mx=x; input.mz=y; });
    bindJoy('stick-r', 'knob-r', (x,y)=> { input.lx=x; input.ly=y; });

    // --- 6. Keyboard Controls ---
    const keys = {};
    let keyboardWActive = false; // Track if keyboard is controlling W axis

    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        updateKeyboardInput();
    });
    window.addEventListener('keyup', e => {
        keys[e.code] = false;
        updateKeyboardInput();
    });

    function updateKeyboardInput() {
        // Movement: WASD or Arrow keys
        let mx = 0, mz = 0;
        if (keys['KeyW'] || keys['ArrowUp']) mz = -1;
        if (keys['KeyS'] || keys['ArrowDown']) mz = 1;
        if (keys['KeyA'] || keys['ArrowLeft']) mx = -1;
        if (keys['KeyD'] || keys['ArrowRight']) mx = 1;
        input.mx = mx;
        input.mz = mz;

        // W axis: Q (W-) and E (W+)
        if (keys['KeyE'] || keys['KeyQ']) {
            keyboardWActive = true;
            input.w = keys['KeyE'] ? 1 : -1;
        } else {
            keyboardWActive = false;
            // Only reset if touch/mouse buttons aren't active
            if (!touchWActive) input.w = 0;
        }
    }

    // Touch/Mouse W buttons
    const btnK = document.getElementById('btn-k');
    const btnA = document.getElementById('btn-a');
    let touchWActive = false;

    const setTouchW = v => {
        if (v !== 0) {
            touchWActive = true;
            input.w = v;
        } else {
            touchWActive = false;
            // Only reset if keyboard isn't active
            if (!keyboardWActive) input.w = 0;
        }
    };

    [btnK, btnA].forEach(b => {
        b.addEventListener('touchstart', e => { e.preventDefault(); setTouchW(b === btnK ? 1 : -1); });
        b.addEventListener('touchend', e => { e.preventDefault(); setTouchW(0); });
        b.addEventListener('mousedown', e => setTouchW(b === btnK ? 1 : -1));
    });
    window.addEventListener('mouseup', () => setTouchW(0));

    // --- 7. Mouse Controls (Look) ---
    let mouseDown = false;
    let mouseLocked = false;

    canvas.addEventListener('mousedown', e => {
        mouseDown = true;
        // Request pointer lock for smoother mouse look
        if (!mouseLocked) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
            }
        }
    });

    window.addEventListener('mouseup', () => {
        mouseDown = false;
    });

    document.addEventListener('pointerlockchange', () => {
        mouseLocked = document.pointerLockElement === canvas;
    });

    document.addEventListener('mozpointerlockchange', () => {
        mouseLocked = document.pointerLockElement === canvas;
    });

    canvas.addEventListener('mousemove', e => {
        if (mouseLocked) {
            // Pointer locked - use movementX/Y directly
            const sensitivity = 0.003;
            cam.yaw += e.movementX * sensitivity;
            cam.pitch -= e.movementY * sensitivity;
            // Clamp pitch to prevent flipping
            cam.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cam.pitch));
        } else if (mouseDown) {
            // Fallback: drag to look
            const sensitivity = 0.003;
            cam.yaw += e.movementX * sensitivity;
            cam.pitch -= e.movementY * sensitivity;
            cam.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cam.pitch));
        }
    });

    // Scroll wheel for Pitch4D (4th dimension rotation)
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const sensitivity = 0.002;
        cam.pitch4D += e.deltaY * sensitivity;
    }, { passive: false });

    // ESC to exit pointer lock (browser handles this, but good to know)
    window.addEventListener('keydown', e => {
        if (e.code === 'Escape' && mouseLocked) {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }
    });

} catch (e) {
    document.body.innerHTML = "ERR: " + e.message;
}
</script>
</body>
</html>
